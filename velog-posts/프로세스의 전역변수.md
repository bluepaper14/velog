# 프로세스의 전역변수

<h3 id="예제">예제</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int global_data = 100; // 전역 변수 선언, 부모/자식 프로세스가 fork() 시 복사

int main() {
    pid_t pid;
    int status;

    printf(&quot;--- 프로세스 생성 및 전역 변수 복사 시작 ---\n&quot;);
    printf(&quot;[시작] 전역 변수 global_data 주소: %p, 값: %d\n&quot;, &amp;global_data, global_data);

    pid = fork(); // 부모 프로세스를 복제, 자식 프로세스 생성

    if (pid &lt; 0) { // fork 실패 시
        perror(&quot;fork 실패&quot;);
        return EXIT_FAILURE;
    } 
    else if (pid == 0) { // 자식 프로세스
        global_data += 20; // 자식 프로세스 전역 변수만 수정
        printf(&quot;[자식] 전역 변수를 +20 수정, 현재 값: %d\n&quot;, global_data);
        sleep(2); // 부모가 waitpid 호출할 시간 확보
        exit(20); // 종료 코드 반환
    } 
    else { // 부모 프로세스
        global_data += 5; // 부모 프로세스 전역 변수만 수정
        printf(&quot;[부모] 전역 변수를 +5 수정. 현재 값: %d\n&quot;, global_data);

        if (waitpid(pid, &amp;status, 0) == -1) { // 자식 종료 기다리기
            perror(&quot;waitpid 실패&quot;);
        } else {
            printf(&quot;[부모] 자식 (%d) 정리 완료. 자식 종료 코드: %d\n&quot;, 
                   pid, WEXITSTATUS(status));
        }

        printf(&quot;\n-- 최종 확인 --\n&quot;);
        printf(&quot;[PID: %d] 최종 전역 변수 값: %d\n&quot;, getpid(), global_data);
        printf(&quot;[결론] (자식이 수정한 20은 반영되지 않고, 부모가 수정한 5만 반영됨)\n&quot;);
        return EXIT_SUCCESS;
    }
}
</code></pre>
<p>1.전역 변수 선언</p>
<pre><code class="language-c">global_data = 100</code></pre>
<p>프로세스 메모리의 데이터 영역(data segment)에 저장된다.  fork() 이전에는 부모 프로세스 하나만 존재 → 값 100이다.</p>
<p>2.fork() 호출</p>
<pre><code class="language-c">pid = fork();</code></pre>
<p>부모 프로세스가 자기 자신을 복제하여 자식 프로세스를 생성한다. 부모와 자식 모두 동일한 코드와 데이터를 갖지만 <u>독립적인 메모리 공간</u>을 가진다. 전역 변수는 <strong>복사본(Copy-On-Write)</strong>을 갖게 되어 서로 공유되지 않는다.</p>
<p>3.최종 확인</p>
<ul>
<li><p>부모에서 출력: global_data = 105</p>
</li>
<li><p>자식에서 출력: global_data = 120</p>
</li>
</ul>
<p>→ 서로 값이 다름. 메모리 공간이 독립적이기 때문</p>
<p><u>전역 변수는 부모/자식 간에 공유되지 않는다</u></p>
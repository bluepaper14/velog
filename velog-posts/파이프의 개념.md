# 파이프의 개념

<h3 id="파이프의-개념">파이프의 개념</h3>
<p>파이프는 두 프로세스가 데이터를 주고 받을 수 있도록 연결하는 커널이 관리하는 메모리 버퍼이다.
일반적으로 흐르는 수도관처럼 파이프를 만들게되면 데이터는 한쪽에서만 쓰기가 가능하고 다른쪽에서는 읽기만 가능하다. 예제를 들어 살펴보자.</p>
<h3 id="예제코드">예제코드</h3>
<pre><code class="language-c">    int fd1[2], fd2[2]; // 두 개의 파이프를 위한 파일 디스크립터 배열 선언
    pid_t pid;          // 프로세스 ID 저장 (fork() 결과)
    int status;         // waitpid()를 위한 종료 상태 변수</code></pre>
<p>2개의 파이프를 위해 파일 디스크립터 배열을 2개 생성하였다. </p>
<p>[0]은 읽기 위한 파일, [1]은 쓰기 위한 파일로 정의하였다.</p>
<ul>
<li><p>fd1 : 부모 -&gt; 자식</p>
</li>
<li><p>fd2 : 자식 -&gt; 부모</p>
<pre><code class="language-c">if (pipe(fd1) == -1) {
      perror(&quot;pipe&quot;);
      exit(1);
  }

  printf(&quot;fd1[0] = %d\n&quot;, fd1[0]); // 3번
  printf(&quot;fd1[1] = %d\n&quot;, fd1[1]); // 4번</code></pre>
<p>pipe 함수를 사용해 파이프를 생성했다. fd 번호는 stdin (0), stdout (1), stderr (2)는 기본적으로 열려 있으므로, 새로 생성된 파이프의 디스크립터는 보통 3번과 4번이 된다.</p>
</li>
</ul>
<pre><code class="language-c">if (pipe(fd2) == -1) {
        perror(&quot;pipe&quot;);
        exit(1);
    }

    printf(&quot;fd2[0] = %d\n&quot;, fd2[0]); // 5번
    printf(&quot;fd2[1] = %d\n&quot;, fd2[1]); // 6번</code></pre>
<p>마찬가지로 두번째 파이프를 생성했다. </p>
<pre><code class="language-c">switch (pid = fork()) {
        case -1:
            perror(&quot;fork&quot;);
            exit(1);
        case 0:    // Child Process (자식 프로세스)
        // ... 자식 프로세스 코드 ...
            break;

        default:   // Parent Process (부모 프로세스)
        // ... 부모 프로세스 코드 ...
            break;
    }</code></pre>
<p>현재 프로세스를 복제하여 자식 프로세스를 생성하였다. -1은 fork 실패를 의미하고 0은 현재 실행중인 프로세스가 자식 프로세스임을 나타낸다. 양수는 부모 프로세스이다. </p>
<pre><code class="language-c">case 0:  // Child Process
            close(fd1[1]);  // fd1의 write 닫기 (자식은 fd1을 '읽기'만 함)
            close(fd2[0]);  // fd2의 read 닫기 (자식은 fd2를 '쓰기'만 함)

            int temp;
            int sum = 0;
            read(fd1[0], &amp;temp, sizeof(temp));
            printf(&quot;child read : %d\n&quot;, temp);

            for(int i = 0; i &lt;= temp; i++) {
                sum += i;
            }

            write(fd2[1], &amp;sum, sizeof(sum));
            printf(&quot;child write : %d\n&quot;, sum);

            close(fd1[0]);
            close(fd2[1]);
            break;</code></pre>
<p>자식 프로세스에서 fd1의 write 는 쓸 필요가 없다.(읽기만 하기 때문) fd2도 쓰기만 하기 때문에 읽기를 닫았다. </p>
<p>자식 프로세스는 <strong>첫 번째 파이프(fd1)</strong>의 읽기 쪽을 통해 부모가 보낸 숫자 100을 받는다. 자식 프로세스는 <strong>첫 번째 파이프(fd1)</strong>의 읽기 쪽을 통해 부모가 보낸 숫자 100을 받는다.</p>
<pre><code class="language-c">#include &lt;sys/wait.h&gt; // waitpid() 함수를 사용하기 위해 포함합니다. (자식 프로세스 종료 대기)
#include &lt;unistd.h&gt;   // fork(), pipe(), read(), write(), close() 함수를 사용하기 위해 포함합니다.
#include &lt;stdlib.h&gt;   // exit() 함수를 사용하기 위해 포함합니다.
#include &lt;stdio.h&gt;    // printf(), perror() 함수를 사용하기 위해 포함합니다.
#include &lt;string.h&gt;   // 문자열 처리 함수를 위한 헤더 (이 코드에서는 직접 사용되지 않음)

int main() {
    int fd1[2], fd2[2]; // 두 개의 파이프를 위한 파일 디스크립터 배열을 선언합니다.
                        // [0]은 읽기(Read), [1]은 쓰기(Write) 디스크립터입니다.
    pid_t pid;          // fork()로 생성된 자식 프로세스의 ID를 저장할 변수입니다.
    int status;         // waitpid() 함수가 자식의 종료 상태를 저장할 변수입니다.

    // --- 1. 첫 번째 파이프(fd1) 생성 (부모 -&gt; 자식 통신용) ---
    if (pipe(fd1) == -1) { // 파이프 생성에 실패하면 -1을 반환합니다.
        perror(&quot;pipe&quot;);   // 에러 메시지 출력
        exit(1);          // 프로그램 종료
    }

    printf(&quot;fd1[0] = %d\n&quot;, fd1[0]); // fd1의 읽기 디스크립터 번호 (일반적으로 3)
    printf(&quot;fd1[1] = %d\n&quot;, fd1[1]); // fd1의 쓰기 디스크립터 번호 (일반적으로 4)

    // --- 2. 두 번째 파이프(fd2) 생성 (자식 -&gt; 부모 통신용) ---
    if (pipe(fd2) == -1) {
        perror(&quot;pipe&quot;);
        exit(1);
    }

    printf(&quot;fd2[0] = %d\n&quot;, fd2[0]); // fd2의 읽기 디스크립터 번호 (일반적으로 5)
    printf(&quot;fd2[1] = %d\n&quot;, fd2[1]); // fd2의 쓰기 디스크립터 번호 (일반적으로 6)

    // --- 3. 프로세스 분기 (fork) ---
    switch (pid = fork()) {
        case -1:
            perror(&quot;fork&quot;); // fork 실패 시 에러 출력
            exit(1);

        case 0:  // Child Process (자식 프로세스) 코드
            // --- 자식 프로세스: 불필요한 파이프 끝 닫기 ---
            close(fd1[1]);  // fd1은 읽기용으로만 사용 (부모가 씀), 쓰기 쪽 닫기
            close(fd2[0]);  // fd2는 쓰기용으로만 사용 (부모가 읽음), 읽기 쪽 닫기
            
            int temp; // 부모로부터 받은 데이터를 저장할 변수 (100)
            int sum = 0; // 계산된 합계를 저장할 변수 (5050)

            // --- 부모로부터 데이터 읽기 (fd1 사용) ---
            // 부모가 fd1[1]에 쓸 때까지 여기서 대기(Blocking)합니다.
            read(fd1[0], &amp;temp, sizeof(temp));
            printf(&quot;child read : %d\n&quot;, temp);
            
            // --- 데이터 처리 (1부터 temp까지 합계 계산) ---
            for(int i = 0; i &lt;= temp; i++) {
                sum += i; // 1 + 2 + ... + 100 = 5050
            }
            
            // --- 결과 데이터를 부모에게 쓰기 (fd2 사용) ---
            write(fd2[1], &amp;sum, sizeof(sum));
            printf(&quot;child write : %d\n&quot;, sum);
            
            // --- 자식 프로세스 종료 전 사용한 디스크립터 닫기 ---
            close(fd1[0]); // fd1 읽기 쪽 닫기
            close(fd2[1]); // fd2 쓰기 쪽 닫기
            break; // 자식 프로세스 종료
            
        default:  // Parent Process (부모 프로세스) 코드
            // --- 부모 프로세스: 불필요한 파이프 끝 닫기 ---
            close(fd1[0]);  // fd1은 쓰기용으로만 사용 (자식이 읽음), 읽기 쪽 닫기
            close(fd2[1]);  // fd2는 읽기용으로만 사용 (자식이 씀), 쓰기 쪽 닫기

            int data, result; // data: 자식에게 보낼 값 (100), result: 자식으로부터 받을 값 (5050)
            data = 100;

            // --- 자식에게 데이터 쓰기 (fd1 사용) ---
            write(fd1[1], &amp;data, sizeof(data));
            printf(&quot;parent write : %d\n&quot;, data);

            // --- 자식의 결과 읽기 (fd2 사용) ---
            // 자식이 fd2[1]에 쓸 때까지 여기서 대기(Blocking)합니다.
            read(fd2[0], &amp;result, sizeof(result));
            printf(&quot;parent read : %d\n&quot;, result);
            
            // --- 부모 프로세스 종료 전 사용한 디스크립터 닫기 ---
            close(fd1[1]); // fd1 쓰기 쪽 닫기
            close(fd2[0]); // fd2 읽기 쪽 닫기

            // --- 자식 프로세스 종료 대기 ---
            // 자식 프로세스가 완전히 종료될 때까지 기다리고 자원을 회수합니다.
            waitpid(pid, &amp;status, 0); 
            break; // 부모 프로세스 종료
    }
    
    return 0; // 프로그램 정상 종료
}</code></pre>
<pre><code class="language-bash">fd1[0] = 3
fd1[1] = 4
fd2[0] = 5
fd2[1] = 6
parent write : 100
child read : 100
child write : 5050
parent read : 5050</code></pre>
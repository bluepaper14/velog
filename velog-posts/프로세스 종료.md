# 프로세스 종료

<h3 id="프로세스-종료">프로세스 종료</h3>
<p>어떠한 프로세스를 종료하는 가장 기본적인 방법은 exit()를 사용한다.</p>
<pre><code class="language-c">void exit (int status)</code></pre>
<p>status는 프로세스 종료시 부모에게 전달하는 값이다. </p>
<p>다른 종료 방법으론 2가지가 있다.</p>
<blockquote>
<p><strong>시그널</strong> : 프로세스를 종료하도록 기본동작이 설정된 신호다.(SIGTERM, SIGKILL)</p>
</blockquote>
<blockquote>
<p><strong>커널에 의한 강제 종료</strong> : 커널이 불법적인 명령 실행, 세그먼테이션 위반, 메모리 부족등의 이유로 프로세스를 강제로 종료시킬수 있다.</p>
</blockquote>
<h3 id="자식-프로세스-대기">자식 프로세스 대기</h3>
<p>부모 프로세스는 wait() 함수를 사용하여 자식 프로세스가 종료되지 않기를 기다린다. 예를 들어보자.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    pid_t pid = fork();  // 자식 생성

    if (pid == 0) {
        // 자식 프로세스
        printf(&quot;자식: 실행 중...\n&quot;);
        sleep(2);
        printf(&quot;자식: 종료합니다.\n&quot;);
        exit(3);  // 종료 코드 3 전달
    } 
    else {
        // 부모 프로세스
        int status;
        printf(&quot;부모: 자식 종료를 기다리는 중...\n&quot;);
        wait(&amp;status);  // 자식이 종료될 때까지 대기

        if (WIFEXITED(status)) {
            printf(&quot;부모: 자식이 정상 종료했습니다. 종료 코드 = %d\n&quot;, WEXITSTATUS(status));
        }
    }

    return 0;
}
</code></pre>
<pre><code class="language-c">pid_t pid = fork();</code></pre>
<p>fork로 현재 프로세스를 복제하여 자식 프로세스를 하나 더 만들었다. 
fork는 한번 호출되지만 부모와 자식 두 번 리턴된다.</p>
<pre><code class="language-c">    if (pid == 0) {
        // 자식 프로세스
        printf(&quot;자식: 실행 중...\n&quot;);
        sleep(2);
        printf(&quot;자식: 종료합니다.\n&quot;);
        exit(3);  // 종료 코드 3 전달
    } </code></pre>
<p>pid 가 0이라는 의미는 현재 코드가 자식 프로세스에서 실행중이라는 의미다. 반대로 pid가 양수면 현재 코드가 부모 프로세스에서 실행중라는 뜻이다.</p>
<h3 id="예제2">예제2</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;   // exit(), EXIT_SUCCESS, EXIT_FAILURE 사용
#include &lt;unistd.h&gt;   // fork(), sleep() 사용
#include &lt;sys/types.h&gt; // pid_t 자료형
#include &lt;sys/wait.h&gt;  // wait(), WIFEXITED, WEXITSTATUS 사용

/**
 * [프로그램 설명]
 * - 부모 프로세스가 fork()를 사용해 자식 프로세스를 만든다.
 * - 자식은 3초간 대기 후 오류 코드(10)로 종료한다.
 * - 부모는 자식이 끝날 때까지 wait()으로 기다린 후
 *   자식이 남긴 종료 코드를 확인한다.
 */
int main() {
    pid_t pid;  // fork()가 반환하는 프로세스 ID를 저장할 변수
    int status; // 자식의 종료 상태를 저장할 변수

    printf(&quot;--- 프로세스 분기 시작 ---\n&quot;);
    printf(&quot;[부모] 초기 PID: %d\n&quot;, getpid());

    // 1️⃣ fork(): 현재 프로세스를 복제 → 부모는 자식의 PID, 자식은 0을 반환받음
    pid = fork();

    // 2️⃣ fork 실패 처리
    if (pid &lt; 0) {
        perror(&quot;fork 실패&quot;);       // 에러 메시지 출력
        exit(EXIT_FAILURE);         // 비정상 종료(코드 1)
    }

    // 3️⃣ 자식 프로세스 구간 (pid == 0)
    else if (pid == 0) {
        printf(&quot;\n[자식 PID: %d] 생성됨. 3초간 대기 중...\n&quot;, getpid());
        sleep(3);  // 실제 작업 대신 3초간 쉬기 (시뮬레이션)

        printf(&quot;[자식 PID: %d] 작업 완료! 오류 코드(10)를 반환하고 종료합니다.\n&quot;, getpid());
        exit(10);  // 종료 코드 10으로 프로그램 종료
    }

    // 4️⃣ 부모 프로세스 구간 (pid &gt; 0)
    else {
        printf(&quot;[부모 PID: %d] 자식(%d) 생성 완료.\n&quot;, getpid(), pid);
        printf(&quot;[부모] wait() 호출: 자식이 끝날 때까지 대기 중...\n&quot;);

        // wait(): 자식이 종료될 때까지 부모는 멈춰서 기다림
        pid_t terminated_pid = wait(&amp;status);

        if (terminated_pid == -1) {
            perror(&quot;wait 실패&quot;);
        } 
        // 자식이 정상적으로 종료된 경우
        else if (WIFEXITED(status)) {
            printf(&quot;[부모] 자식 프로세스(%d) 정상 종료 확인.\n&quot;, terminated_pid);
            printf(&quot;[부모] 자식의 종료 코드(Exit Status): %d\n&quot;, WEXITSTATUS(status));
        }

        printf(&quot;\n[부모 PID: %d] 모든 임무 완료. 정상 종료 코드(0) 반환.\n&quot;, getpid());
        exit(EXIT_SUCCESS); // 정상 종료(코드 0)
    }

    return 0; // 실제로는 도달하지 않음 (exit()으로 이미 종료)
}</code></pre>
<p>요약하면 이거다.
1.fork() 호출 - 부모가 자식을 생성
2.자식이 exit() 호출 - 자식 종료
3.커널이 부모에서 SIGCHLD 시그널 - 자식이 종료됨을 알림
4.부모 wait() 호출 - 커널에서 자식의 종료를 받아옴. 그때동안 기다림
5.커널이 자식의 종료코드 전달 - 부모는 WEXITSTATUS(status)로 확인</p>